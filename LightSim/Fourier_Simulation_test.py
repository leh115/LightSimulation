import unittest
from LightProp import LightSim
from Propagate import Propagate
from MultiMode import ModePosition as mulmo
from Beam_Analysis import Beam_Analyser
from UpdatePlanes import Updater
from Visualiser import Visualiser
import numpy as np
import cv2


class Test_Simulation(unittest.TestCase):
    InitialBeamWaist = 40e-6
    spotSeparation = np.sqrt(4) * InitialBeamWaist

    # * Set up all of the class instances
    mode_maker = mulmo(Amplitude=5)
    propagator1 = Propagate()
    propagator2 = Propagate(override_dz=True)
    analyse = Beam_Analyser()
    plane_update = Updater(mask_offset=0.0005)
    visual = Visualiser(False)
    Modes = mode_maker.makeModes(
        InitialBeamWaist,
        spotSeparation,
        "Square",
        "Spot",
    )

    def setUp(self):
        LightSim.number_of_modes = 5
        LightSim.kFilter = 1
        LightSim.filter_on = (
            False  # If the filter is on then all reproducible tests will fail
        )
        LightSim.ccd_size_factor = 2
        LightSim.resolution = 1

    # * Choose a Mode to test
    test_mode1 = Modes[3][0]

    # * Choose a Plane to test
    test_plane1 = 0

    # Test 1
    def test_Forwards_Propagation(self):
        """Tests that forward propagation generates a larger beam in free space"""

        test_mode = self.Modes[0][0]
        propagator = Propagate()
        integer_multiple = 20
        z_distance = (
            propagator.dz * integer_multiple
        )  # needs to be an integer multiple of dz otherwise override dz will not produce same results
        
        propagator[:] = test_mode
        propagator >> z_distance

        self.assertEqual(len(propagator[:]), integer_multiple+1)
        self.assertGreater(
            self.analyse.beam_width(propagator[-1]),
            self.analyse.beam_width(test_mode),
        )
        
        propagator2 = Propagate(override_dz=True)
        # * Now test that by overriding the dz value only 1 calculation is made (so there is only an initial (1) and final (1) cross section (1+1=2 sections)) and also that this produces roughly equivalent results to calculating a larger number of cross sections without the override
        propagator2[:] = test_mode
        propagator2 >> z_distance
        self.assertEqual(len(propagator2[:]), 2)
        self.assertAlmostEqual(
           np.sum(propagator[-1]),
           np.sum(propagator2[-1]),msg="Overide dz not equal"
        )

        if (
            z_distance > propagator.dz * 19
        ):  # gouy doesn't work for low propagation distances
            # * Now test the Gouy phase shift
            propagator.show_beam = False  # otherwise fast flashes
            plane_wave = np.ones((propagator.Nx, propagator.Ny), dtype=np.complex128)
            propagator[:] = plane_wave
            propagator >> z_distance
            plane_shift = np.angle(
                propagator[-1][
                    int(propagator.Nx / 2 - 1), int(propagator.Ny / 2 - 1)
                ]
            )  # get the central value
            gauss_shift = np.angle(
                propagator2[-1][
                    int(propagator2.Nx / 2 - 1), int(propagator2.Ny / 2 - 1)
                ]
            )

            sim_gouy_shift = plane_shift - gauss_shift
            gouy_phase_shift = -np.arctan(
                z_distance / propagator2.Rayleigh_Length(self.InitialBeamWaist)
            )

            if gouy_phase_shift < 0:
                gouy_phase_shift = 2 * np.pi + gouy_phase_shift
            if sim_gouy_shift < 0:
                sim_gouy_shift = 2 * np.pi + sim_gouy_shift
            # This is not very accurate at all, but it does get to within 1 decimal place consistently once z is large enough
            self.assertAlmostEqual(
                sim_gouy_shift,
                gouy_phase_shift,
                1,
                msg=f"Gouy phase shift should be: {gouy_phase_shift}",
            )

    # Test 2
    def test_reproducible_propagation(self):
        """Tests that forwards propagation followed by equal distance backwards propagation reproduces the same beam cross section in free space"""
        LightSim.ccd_size_factor = 4
        LightSim.resolution = 1
        z_distance = 5 * 20e-3
        self.propagator1[:] = self.test_mode1
        self.propagator1 >> z_distance
        z_distance << self.propagator1

        # * Test the beam width is equal
        self.assertAlmostEqual(
            self.analyse.beam_width(self.propagator1[-1]),
            self.analyse.beam_width(self.test_mode1),
        )

        # * Test the real components are equal to 7 decimal places
        self.assertAlmostEqual(
            np.real(np.sum(self.propagator1[-1])),
            np.real(np.sum(self.test_mode1)),
        )

        # * Test that the imaginary component returns to its initial value (which should be 0 for modes generated by mulmo)
        self.assertAlmostEqual(
            np.imag(np.sum(self.propagator1[-1])),
            np.imag(np.sum(self.test_mode1)),
        )

    # Test 3
    def test_reproducible_planes(self):
        """Tests that forwards and backwards through a plane produces equivalent results"""

        self.propagator1[:] = self.test_mode1
        self.propagator1 | self.test_plane1  # this is less clear than for >>, but this is forwards
        self.test_plane1 | self.propagator1  # and this is backwards

        # * Test that there are only 3 cross sections: initial, after going through plane, after coming back through plane
        self.assertEqual(len(self.propagator1[:]), 3)

        # * Test the real components are equal to 7 decimal places
        self.assertAlmostEqual(
            np.real(np.sum(self.propagator1[-1])),
            np.real(np.sum(self.test_mode1)),
        )

        # * Test that the imaginary component returns to its initial value (which should be 0 for modes generated by mulmo)
        self.assertAlmostEqual(
            np.imag(np.sum(self.propagator1[-1])),
            np.imag(np.sum(self.test_mode1)),
        )

    # Test 4
    def test_reproducible_planes_and_propagation(self):
        """Tests that combining planes with propagation still works by going forwards and then backwards through the system"""

        for _ in range(2):
            self.propagator1[:] = self.test_mode1
            self.propagator1.Propagate_FromPlane_ToPlane(
                0, len(self.propagator1.PlaneSetUp)
            )
            self.propagator1.Propagate_FromPlane_ToPlane(
                0, len(self.propagator1.PlaneSetUp), Forwards=False
            )

            self.propagator2[:] = self.test_mode1
            self.propagator2.Propagate_FromPlane_ToPlane(
                0, len(self.propagator1.PlaneSetUp)
            )

            # * Test that for override dz a system with n planes has 2n + 1 cross sections + initial cross section
            self.assertEqual(
                len(self.propagator2.Beam_Cross_Sections),
                2 * (len(self.propagator1.PlaneSetUp) - 1) + 2,
            )

            self.propagator2.Beam_Cross_Sections = self.test_mode1
            self.propagator2.Propagate_FromPlane_ToPlane(
                0, len(self.propagator1.PlaneSetUp), Forwards=False
            )

            # * Test that for override dz a system with n planes has 2n + 1 cross sections + initial cross section when going backwards
            self.assertEqual(
                len(self.propagator2.Beam_Cross_Sections),
                2 * (len(self.propagator1.PlaneSetUp) - 1) + 2,
            )

            # * Test the real components are equal to 7 decimal places
            self.assertAlmostEqual(
                np.real(np.sum(self.propagator1.Beam_Cross_Sections[-1])),
                np.real(np.sum(self.test_mode1)),
            )

            # * Test that the imaginary component returns to its initial value (which should be 0 for modes generated by mulmo)
            self.assertAlmostEqual(
                np.imag(np.sum(self.propagator1.Beam_Cross_Sections[-1])),
                np.imag(np.sum(self.test_mode1)),
            )

            Noisy_Plane = np.zeros(
                (self.propagator1.Nx, self.propagator1.Ny), dtype=np.complex128
            )
            Noisy_Plane.real = np.random.normal(
                0, 1, (self.propagator1.Nx, self.propagator1.Ny)
            )
            Noisy_Plane.imag = np.random.normal(
                0, 1, (self.propagator1.Nx, self.propagator1.Ny)
            )
            self.propagator1.Planes[self.test_plane1] = Noisy_Plane

    # Test 5
    def test_update_intermediate_value_theorem(self):
        """The value of the updated plane should lie somewhere between the values of the Forward and Backward Fields.
        Important note: changing mask_offset (commented out below) may cause test to fail, this is both a good thing (helps us test mask offset in system) and bad because too high mask offset will stop the value from being intermediate
        """
        LightSim.number_of_modes = 1
        mode_maker = mulmo(Amplitude=5)
        Modes = mode_maker.makeModes(
            40e-6,
            np.sqrt(4) * 40e-6,
            "Square",
            "Spot",
        )
        z_distance = 20e-3
        propagator1 = Propagate(override_dz=True, show_beam=False)
        propagator1.Beam_Cross_Sections = Modes[0][0]
        InitialPlane = propagator1.Planes[self.test_plane1].copy()
        propagator1 >> z_distance
        F = propagator1.Beam_Cross_Sections.copy()
        propagator1 >> z_distance  # go forward another dz so now at 2 * dz
        z_distance << propagator1  # and return so that now field is conjugate
        B = propagator1.Beam_Cross_Sections.copy()
        plane_update = Updater()
        plane_update.mask_offset *= 1
        plane_update.UpdatePhasePlane(
            F[-1], B[-1], propagator1.Planes[self.test_plane1], self.test_plane1
        )

        # * needs to be pushed to the LightSim class
        for plane_num, updated_plane in enumerate(plane_update.updated_planes):
            plane_update.Planes[plane_num] = updated_plane
        LightSim.Planes = plane_update.Planes

        propagator1 = Propagate(
            show_beam=False
        )  # must re-start the class for new class variables to take effect

        # * Test first that there has been an update
        updated_plane = propagator1.Planes[self.test_plane1]
        self.assertNotEqual(
            np.sum(np.real(updated_plane)), np.sum(np.real(InitialPlane))
        )
        self.assertNotEqual(
            np.sum(np.imag(updated_plane)), np.sum(np.imag(InitialPlane))
        )

        # * Find the more positive field
        if np.sum(np.real(F)) > np.sum(np.real(B)):
            more_positive_real = np.sum(np.real(F))
            less_positive_real = np.sum(np.real(B))
        else:
            more_positive_real = np.sum(np.real(B))
            less_positive_real = np.sum(np.real(F))

        if np.sum(np.imag(F)) > np.sum(np.imag(B)):
            more_positive_imag = np.sum(np.imag(F))
            less_positive_imag = np.sum(np.imag(B))
        else:
            more_positive_imag = np.sum(np.imag(B))
            less_positive_imag = np.sum(np.imag(F))

        # * Test now that the new plane is intermediate between the two fields in both real and imaginary components, messages contain mask offset because that's probably why this test will fail
        self.assertLess(
            less_positive_real - np.sum(np.real(updated_plane)),
            0,
            "Real too big: Mask Offset " + str(plane_update.mask_offset),
        )
        self.assertGreater(
            more_positive_real - np.sum(np.real(updated_plane)),
            0,
            "Real too small: Mask Offset " + str(plane_update.mask_offset),
        )

        self.assertLess(
            less_positive_imag - np.sum(np.imag(updated_plane)),
            0,
            "Imag too big: Mask Offset " + str(plane_update.mask_offset),
        )
        self.assertGreater(
            more_positive_imag - np.sum(np.imag(updated_plane)),
            0,
            "Imag too small: Mask Offset " + str(plane_update.mask_offset),
        )

    def test_state_normalisation(self):
        """The maximum value of all of the modes should be 1."""
        mode_maker = mulmo(Amplitude=1)
        modes = mode_maker.makeModes(
            self.InitialBeamWaist, self.spotSeparation, "Square", "Spot"
        )
        # * all following modes should be equal normalisation to the test normalisation
        test_Normalisation = np.max(np.abs(modes))
        for patterns in ["Square", "Central", "Fib"]:
            for mode_type in ["HG", "Spot"]:
                modes = mode_maker.makeModes(
                    self.InitialBeamWaist, self.spotSeparation, patterns, mode_type
                )
                self.assertEqual(
                    np.max(np.abs(modes)),
                    test_Normalisation,
                    patterns + " " + mode_type,
                )

    # def test_FWHM(self):
    #     mode_maker = mulmo([0.1], 1, 1)
    #     Modes = mode_maker.makeModes(
    #     self.InitialBeamWaist,
    #     0,
    #     "Central",
    #     "Spot",
    #     )

    #     self.visual.show_Initial(Modes,self.Modes,500)

    #     fwhm0,w0 = self.analyse.FWHM(Modes)
    #     self.propagator2.Beam_Cross_Sections = Modes[0][0]
    #     self.propagator2 >> 10 * 20e-1
    #     fwhm1,w1 = self.analyse.FWHM(self.propagator2.Beam_Cross_Sections)
    #     self.assertAlmostEqual(w0,w1)
    # def test_
    # @unittest.SkipTest

    def test_multi_mode_interaction(self):
        """When Multiple modes propagate through a system they should both affect the phase plane in the same way that two single modes would."""

        initial_beam_waist = 30e-6
        mode_maker2 = mulmo(Amplitude=1)
        Planes = []
        plane_angles = [
            [np.random.rand() * 2 - 1, np.random.rand() * 2 - 1]
        ]  # choose some random phase plane
        expected_real = [np.cos(np.angle(plane_angles[0][0] + 1j * plane_angles[0][1]))]
        expected_imaginary = [
            np.sin(np.angle(plane_angles[0][0] + 1j * plane_angles[0][1]))
        ]

        for plane_angle, eim, ere in zip(
            plane_angles, expected_imaginary, expected_real
        ):
            for (
                i,
                number_of_modes,
                start_mode,
            ) in zip([1, 2, 3], [1, 2, 2], [0, 1, 0]):
                LightSim.Planes = None
                LightSim.number_of_modes = number_of_modes
                LightSim.phase_plane_components = plane_angle
                input_modes, output_modes = mode_maker2.make_input_output_modes(
                    initial_beam_waist,
                    initial_beam_waist,
                    120e-6,
                    120e-6,
                    "left_right -> central",
                    "spot -> spot",
                    start_mode=start_mode,
                )
                updater2 = Updater()
                updater2.show_modes_at_start = False
                updater2.mask_offset *= 0
                mask_offset = updater2.mask_offset.copy()
                updater2.GradientDescent(
                    input_modes,
                    output_modes,
                    EpochNumber=1,
                    samplingRate=1,
                    show_Propagation_live=False,
                )
                Planes.append(LightSim.Planes.copy())
                del updater2

                multi_mode_factor = 1
                if i == 3:
                    multi_mode_factor = 2

                self.assertAlmostEqual(
                    np.imag(
                        np.sum(
                            Planes[-1][self.test_plane1]
                            - multi_mode_factor * mask_offset
                        )
                    ),
                    eim * multi_mode_factor,
                    msg=f"Plane {str(i)} imaginary components not {eim*multi_mode_factor}, Phase Plane Angle: {np.angle(plane_angle[0]+1J*plane_angle[1])}",
                )

                self.assertAlmostEqual(
                    np.real(
                        np.sum(
                            Planes[-1][self.test_plane1]
                            - multi_mode_factor * mask_offset
                        )
                    ),
                    ere * multi_mode_factor,
                    msg=f"Plane {str(i)} real components not {ere*1*multi_mode_factor}, Phase Plane Angle: {np.angle(plane_angle[0]+1J*plane_angle[1])}",
                )

        # self.assertEqual( np.real(np.sum(Planes3[self.test_plane1] - (Planes1[self.test_plane1] + Planes2[self.test_plane1]))) , 0, msg="Plane difference not 0")

        # * A section for smaller, subclass tests that are not relevant to theory and just test that things are sort of working as expected.
